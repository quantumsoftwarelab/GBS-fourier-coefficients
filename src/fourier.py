# This module contains the function to calculate the Fourier coefficient and the required helper functions.

import itertools
import math
import numpy as np

from thewalrus import threshold_detection_prob


def generate_all_strings(n: int):
    """
    Find all permutations of bitstrings of length n
    :param n: number of bits/modes
    :return: list of strings
    """
    strings = []
    # use binary representation to find the strings
    for i in range(1 << n):
        string = format(i, '0' + str(n) + 'b')
        strings.append(string)
    strings.reverse()
    return strings


def kbits(n, k):
    """
    Returns all bit strings of mode n with of order k

    :param n: modes
    :param k: order (# of 1's)
    :return: list of lists of bits (i.e. bitstrings) of order k
    """
    result = []
    for bits in itertools.combinations(range(n), k):
        s = ['0'] * n
        for bit in bits:
            s[bit] = '1'
        result.append([int(x) for x in s])
    return result


def calculate_coef_with_probs(string: str, mu: np.ndarray, cov: np.ndarray):
    """
    Calculate the Fourier coefficients with the probabilities generated by StrawberryFields.
    Can be used to verify correctness of Fourier coefficients calculated with other method.
    :param string: string of 0s and 1s (this is not the string of the state we want to calculate the prob of)
    :param mu: mean vector of output state
    :param cov: covariance matrix of output state
    :return: fourier coefficient (to be summed with others if we want to calculate probabilities)
    """
    curr_int = int(string, 2)
    coef = 0
    strings = generate_all_strings(len(string))
    for el in strings:
        # calculate sign based on dot product of two strings
        sign = -1 if int.bit_count(curr_int & int(el, 2)) % 2 == 1 else 1
        coef += sign * threshold_detection_prob(mu, cov, list(map(int, list(el)))).real

    return coef / (2 ** len(string))


def calculate_probs_using_coef(string, mu, cov):
    """
    Calculate probability of given output using Fourier coefficients.
    Formula applied is Equation 3.6 in the dissertation linked in README.
    :param string: bitstring that represents the outcome
    :param mu: mean vector of output state
    :param cov: covariance matrix of output state
    :return:
    """
    prob = 0
    strings = generate_all_strings(len(string))
    curr_int = int(string, 2)
    for el in strings:
        sign = -1 if int.bit_count(curr_int & int(el, 2)) % 2 == 1 else 1
        prob += sign * fourier_coefficient([int(char) for char in el], cov)

    return prob


def generate_combos_of_1_indices(bits: list):
    """
    Finds indices of all 1s and then finds all permutations of said indices
    (helper method for obtaining all necessary submatrices of cov)
    :param bits: list representation of bitstring
    :return: list of index combinations
    """
    indices = [i for i, x in enumerate(bits) if x == 1]
    combinations = []
    for i in range(len(indices) + 1):
        combinations += itertools.combinations(indices, i)
    combinations = [list(x) for x in combinations]
    return combinations


def retrieve_submatrix(cov, modes):
    """
    :param cov: covariance matrix
    :param modes: list of modes
    :return: submatrix of the given modes
    """
    n = len(cov) / 2
    indices = modes + [x + n for x in modes]  # modes are mapped to the rows and columns of submatrix
    row = np.take(cov, indices, 0)
    row_and_column = np.take(row, indices, 1)
    return row_and_column


def fourier_coefficient(bits: list, cov: np.ndarray):
    """
    Calculates fourier coefficient of given bits using Z gate & density matrix -> Wigner Function integration.
    Formula used is Equation 3.13 in the dissertation linked in README.
    :param bits: list representation of bitstring
    :param cov: covariance matrix
    :return: fourier coefficient of given bits
    """
    order = np.count_nonzero(bits)
    combinations = generate_combos_of_1_indices(bits)
    coefficient = 0

    for combo in combinations:
        size = len(combo)
        sign = (-1) ** (order - size)

        if size == 0:
            coefficient += sign * 1
            continue

        else:
            det = np.linalg.det(retrieve_submatrix(cov, combo) + np.eye(size * 2))
            value = 2 ** (2 * size) / math.sqrt(det)
            coefficient += sign * value

    coefficient = coefficient / (2 ** len(bits))
    return coefficient
